Q1. Explain the difference between greedy and non-greedy syntax with visual terms in as few words
as possible. What is the bare minimum effort required to transform a greedy pattern into a non-greedy
one? What characters or characters can you introduce or change?

Q2. When exactly does greedy versus non-greedy make a difference?Â  What if you&#39;re looking for a
non-greedy match but the only one available is greedy?

Q3. In a simple match of a string, which looks only for one match and does not do any replacement, is
the use of a nontagged group likely to make any practical difference?

Q4. Describe a scenario in which using a nontagged category would have a significant impact on the
program&#39;s outcomes.

Q5. Unlike a normal regex pattern, a look-ahead condition does not consume the characters it
examines. Describe a situation in which this could make a difference in the results of your
programme.

Q6. In standard expressions, what is the difference between positive look-ahead and negative look-
ahead?

Q7. What is the benefit of referring to groups by name rather than by number in a standard
expression?

Q8. Can you identify repeated items within a target string using named groups, as in &quot;The cow
jumped over the moon&quot;?

Q9. When parsing a string, what is at least one thing that the Scanner interface does for you that the
re.findall feature does not?

Q10. Does a scanner object have to be named scanner?

SOLUTIONS.
Q1. Greedy syntax matches as much as possible, while non-greedy syntax matches as little as possible. To transform a greedy pattern into a non-greedy one, you can introduce a question mark "?" after the quantifier.

Q2. Greedy versus non-greedy makes a difference when there are multiple possible matches in a string. If you're looking for a non-greedy match but only a greedy match is available, you will get the longest possible match instead of the shortest.

Q3. In a simple string match without replacement, the use of a non-tagged group is unlikely to make any practical difference.

Q4. Using a non-tagged category can have a significant impact when you want to match or exclude specific patterns within a larger text and perform different actions based on the matched category.

Q5. In a lookahead condition, the characters being examined are not consumed, which means they are not included in the actual match. This can make a difference when you want to find overlapping patterns or perform conditional matches without including the lookahead characters in the result.

Q6. Positive lookahead (x(?=y)) matches x only if it is followed by y, while negative lookahead (x(?!y)) matches x only if it is not followed by y.

Q7. Referring to groups by name in a standard expression improves code readability and makes the intention of the pattern clearer. It also allows for easier maintenance if the group order changes.

Q8. Yes, you can identify repeated items within a target string using named groups. For example, in the string "The cow jumped over the moon," you can use a named group like "(?P<word>\w+)" to capture repeated words and access them by name.

Q9. When parsing a string, the Scanner interface provides additional functionality compared to the re.findall feature. The Scanner allows you to tokenize a string, skip certain patterns, and control the scanning process more precisely.

Q10. No, a Scanner object does not have to be named "scanner." You can choose any valid variable name for your Scanner object as long as it follows the naming conventions of the programming language you are using.



















